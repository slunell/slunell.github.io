<!DOCTYPE html>
<html>

<head>
    <meta charset=utf-8>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>Glass</title>

    <script src="js/three.js"></script>
    <script src="js/OrbitControls.js"></script>

    <style>
        #main {
            overflow: hidden;
        }

        body {
            margin: 0;
        }

    </style>
</head>

<body>
    <div id="main"></div>

    <script>
        var WIDTH = window.innerWidth;
        var HEIGHT = window.innerHeight;
        var ASPECT = WIDTH / HEIGHT;

        var scene, camera, renderer, controls;
        var polygons = [];
        var rot_shapes = [];
        var rot_ids = [];
        var palette1 = ['#E3DFFF', '#D3C0CD', '#B19994', '#937666', '#3D3A4B'];
        var palette2 = ['#393D3F', '#f2f2f2', '#C6C5B9', '#62929E', '#546A7B'];
        var palette3 = ['#BFB5AF', '#ECE2D0', '#D5B9B2', '#A26769', '#582C4D'];
        var num_shapes = 125;
        var mouse = new THREE.Vector2();
        var raycaster = new THREE.Raycaster();

        function init() {
            // create a WebGL renderer inside an existing dom element (id=main)
            renderer = new THREE.WebGLRenderer();
            renderer.setClearColor(new THREE.Color('white'));
            renderer.setSize(WIDTH, HEIGHT);

            document.getElementById("main").appendChild(renderer.domElement);

            scene = new THREE.Scene();

            // Add camera
            camera = new THREE.PerspectiveCamera(45, ASPECT, 1, 10000);
            scene.add(camera);
            // the camera starts at 0,0,0, so pull it back
            camera.position.set(100, 30, 50);

            // Move camera around
            controls = new THREE.OrbitControls(camera, renderer.domElement);

            createShape();
            createShape1();

            document.addEventListener('mousemove', onDocumentMouseMove, false);
            window.addEventListener('resize', onWindowResize, false);

            animate();
        }

        function onDocumentMouseMove(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Random radian value
        function randRotation() {
            return Math.random() * (2 * Math.PI);
        }

        function randX() {
            return Math.random() * (10 - (1)) + (1);
        }

        function randZ() {
            return Math.random() * (50 - (-50)) + (-50);
        }

        function createShape() {
            // Create a sine-like wave
            var curve = new THREE.SplineCurve([
                new THREE.Vector2(-10, 0),
                new THREE.Vector2(-5, 15),
                new THREE.Vector2(0, 0),
                new THREE.Vector2(5, -5),
                new THREE.Vector2(10, 0)
            ]);

            var points = curve.getPoints(50);
            var geometry = new THREE.BufferGeometry().setFromPoints(points);

            var material = new THREE.LineBasicMaterial({
                color: 0xff0000
            });

            // Create the final object to add to the scene
            var splineObject = new THREE.Line(geometry, material);

            scene.add(splineObject);

        }

        function createShape1() {
            // Create a sine-like wave
            var curve = new THREE.SplineCurve([
                new THREE.Vector2(-5, 15),
                new THREE.Vector2(0, 0),
                new THREE.Vector2(5, -5),
                new THREE.Vector2(10, 0),
                new THREE.Vector2(15, -5)
            ]);

            var points = curve.getPoints(50);
            var geometry = new THREE.BufferGeometry().setFromPoints(points);

            var material = new THREE.LineBasicMaterial({
                color: 0xff00f0
            });

            // Create the final object to add to the scene
            var splineObject = new THREE.Line(geometry, material);

            scene.add(splineObject);

        }

        function animate() {
            requestAnimationFrame(animate);

            render();
        }
        var count = 0;

        function render() {
            //            raycaster.setFromCamera(mouse, camera);
            //            var intersects = raycaster.intersectObjects(scene.children);
            //            if (intersects.length > 0) {
            //                if (rot_ids.indexOf(intersects[0].object.geometry.uuid) == -1) {
            //                    rot_shapes.push(intersects[0]);
            //                    rot_ids.push(intersects[0].object.geometry.uuid);
            //                }
            //            }
            //
            //            for (var i = 0; i < rot_shapes.length; i++) {
            //                var shape = rot_shapes[i];
            //
            //                if (shape.object.position.y > -100) {
            //                    shape.object.rotation.x += 0.05;
            //                    shape.object.position.y -= 0.5;
            //                }
            //            }
            renderer.render(scene, camera);
        }

        init();

    </script>
</body>

</html>
